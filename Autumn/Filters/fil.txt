#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <windows.h>
#include < math.h >

BITMAPFILEHEADER bitmapFileHeader;
BITMAPINFOHEADER bitmapInfoHeader;
RGBTRIPLE **bitecolor;

//	printf("%d %d %d %d ", bitecolor[i][j].rgbtBlue, bitecolor[i][j].rgbtGreen, bitecolor[i][j].rgbtRed, bitecolor[i][j].rgbtReserved);

int comp(const void *i, const void *j)
{
	return *(int *)i - *(int *)j;
}

median(BITMAPINFOHEADER bitmapInfoHeader, BITMAPFILEHEADER bitmapFileHeader, RGBTRIPLE **bitecolor)
{
	int R[9], B[9], G[9];

	for (int a = 1; a < bitmapInfoHeader.biWidth - 1; a++)
		for (int b = 1; b < bitmapInfoHeader.biHeight - 1; b++)
		{
			int k = 0;
			for (int i = -1; i < 2; i++)
				for (int j = -1; j < 2; j++)
				{
					R[k] = bitecolor[i + a][j + b].rgbtRed;
					G[k] = bitecolor[i + a][j + b].rgbtGreen;
					B[k] = bitecolor[i + a][j + b].rgbtBlue;
					k++;
				}
			qsort(R, 9, sizeof(int), comp);
			qsort(G, 9, sizeof(int), comp);
			qsort(B, 9, sizeof(int), comp);
			bitecolor[a][b].rgbtBlue = B[4];
			bitecolor[a][b].rgbtRed = R[4];
			bitecolor[a][b].rgbtGreen = G[4];
		}


	createbmp(bitmapInfoHeader, bitmapFileHeader, bitecolor);

}

grey(BITMAPINFOHEADER bitmapInfoHeader, BITMAPFILEHEADER bitmapFileHeader, RGBTRIPLE **bitecolor)
{
	int R, G, B, Y;

	for (int i = 0; i < bitmapInfoHeader.biWidth; i++)
		for (int j = 0; j < bitmapInfoHeader.biHeight; j++)
		{
			R = bitecolor[i][j].rgbtRed;
			G = bitecolor[i][j].rgbtGreen;
			B = bitecolor[i][j].rgbtBlue;
			Y = 0.299 * R + 0.587 * G + 0.114 * B;
			bitecolor[i][j].rgbtRed = Y;
			bitecolor[i][j].rgbtGreen = Y;
			bitecolor[i][j].rgbtBlue = Y;
		}
	createbmp(bitmapInfoHeader, bitmapFileHeader, bitecolor);
}

RGBTRIPLE **newbitecolor;
gauss(int r, BITMAPINFOHEADER bitmapInfoHeader, BITMAPFILEHEADER bitmapFileHeader, RGBTRIPLE **bitecolor)
{

	newbitecolor = (RGBTRIPLE **)malloc(sizeof(RGBTRIPLE*) * bitmapInfoHeader.biWidth);
	for (int j = 0; j < bitmapInfoHeader.biWidth; j++)
		newbitecolor[j] = (RGBTRIPLE *)malloc(sizeof(RGBTRIPLE) * bitmapInfoHeader.biHeight);


	for (int i = 0; i < bitmapInfoHeader.biWidth; i++)
		for (int j = 0; j < bitmapInfoHeader.biHeight; j++)
		{
			newbitecolor[i][j].rgbtRed = bitecolor[i][j].rgbtRed;
			newbitecolor[i][j].rgbtGreen = bitecolor[i][j].rgbtGreen;
			newbitecolor[i][j].rgbtBlue = bitecolor[i][j].rgbtBlue;
		}


	double gaussArray[5][5], div = 0;
	int pixelPosX, pixelPosY;

	for (int i = 0; i < 5; i++)
		for (int j = 0; j < 5; j++)
		{
			gaussArray[i][j] = (double)(1 / (3.14 * 2 * r * r)) * exp((abs((5 / 2) - i) * abs((5 / 2) - i)) * (-1.0) / (2 * r * r));
			div += gaussArray[i][j];
		}

	for (int y = 2; y < bitmapInfoHeader.biHeight - 2; y++)
		for (int x = 2; x < bitmapInfoHeader.biWidth - 2; x++)
		{
			double rSum = 0, gSum = 0, bSum = 0, kSum = 0;
			for (int i = 0; i < 5; i++)
				for (int j = 0; j < 5; j++)
				{
					pixelPosX = x + j - 2;
					pixelPosY = y + i - 2;

					byte red = newbitecolor[pixelPosY][pixelPosX].rgbtRed;
					byte green = newbitecolor[pixelPosY][pixelPosX].rgbtGreen;
					byte blue = newbitecolor[pixelPosY][pixelPosX].rgbtBlue;

					double kernelVal = gaussArray[i][j];

					rSum += red * kernelVal;
					gSum += green * kernelVal;
					bSum += blue * kernelVal;

					kSum += kernelVal;
				}

			if (kSum <= 0) kSum = 1;

			rSum /= kSum;
			if (rSum < 0) rSum = 0;
			if (rSum > 255) rSum = 255;

			gSum /= kSum;
			if (gSum < 0) gSum = 0;
			if (gSum > 255) gSum = 255;

			bSum /= kSum;
			if (bSum < 0) bSum = 0;
			if (bSum > 255) bSum = 255;

			newbitecolor[y][x].rgbtRed = (byte)rSum;
			newbitecolor[y][x].rgbtGreen = (byte)gSum;
			newbitecolor[y][x].rgbtBlue = (byte)bSum;
		}

	createbmp(bitmapInfoHeader, bitmapFileHeader, newbitecolor);
}

createbmp(BITMAPINFOHEADER bitmapInfoHeader, BITMAPFILEHEADER bitmapFileHeader, RGBTRIPLE **bitecolor)
{
	FILE *newfile = fopen("a.bmp", "wb");

	fwrite(&bitmapFileHeader, sizeof(BITMAPFILEHEADER), 1, newfile);
	fwrite(&bitmapInfoHeader, sizeof(BITMAPINFOHEADER), 1, newfile);
	fseek(newfile, bitmapFileHeader.bfOffBits, SEEK_SET);
	int padding = (-((bitmapInfoHeader.biWidth * bitmapInfoHeader.biBitCount / 8) % 4) + 4) % 4;
	char *buf = malloc(sizeof(char) * 4);
	for (int i = 0; i < bitmapInfoHeader.biWidth; i++)
	{
		for (int j = 0; j < bitmapInfoHeader.biHeight; j++)
			fwrite(&(bitecolor[i][j]), sizeof(bitecolor[i][j]), 1, newfile);
		fread(buf, sizeof(BYTE), padding, newfile);
	}

	fclose(newfile);
}

sobelx(BITMAPINFOHEADER bitmapInfoHeader, BITMAPFILEHEADER bitmapFileHeader, RGBTRIPLE **bitecolor)
{
	int g[3][3] = { { -1, 0, 1 }, { -2, 0, 2 }, { -1, 0, 1 } };

	int newr = 0, newg = 0, newb = 0;
	int rc, gc, bc;
	for (int i = 1; i < bitmapInfoHeader.biWidth - 1; i++)
		for (int j = 1; j < bitmapInfoHeader.biHeight - 1; j++)
		{

			newr = 0; newg = 0; newb = 0;
			rc = 0; gc = 0; bc = 0;

			for (int wi = -1; wi < 2; wi++)
				for (int hw = -1; hw < 2; hw++)
				{
					rc = bitecolor[i + hw][j + wi].rgbtRed;
					newr += g[wi + 1][hw + 1] * rc;

					gc = bitecolor[i + hw][j + wi].rgbtGreen;
					newg += g[wi + 1][hw + 1] * gc;

					bc = bitecolor[i + hw][j + wi].rgbtBlue;
					newb += g[wi + 1][hw + 1] * bc;
				}

			bitecolor[i][j].rgbtBlue = newb;
			bitecolor[i][j].rgbtGreen = newg;
			bitecolor[i][j].rgbtRed = newr;
		}

	createbmp(bitmapInfoHeader, bitmapFileHeader, bitecolor);
}

sobely(BITMAPINFOHEADER bitmapInfoHeader, BITMAPFILEHEADER bitmapFileHeader, RGBTRIPLE **bitecolor)
{
	int g[3][3] = { { 1, 2, 1 }, { 0, 0, 0 }, { -1, -2, -1 } };

	int newr = 0, newg = 0, newb = 0;
	int rc, gc, bc;
	for (int i = 1; i < bitmapInfoHeader.biWidth - 1; i++)
		for (int j = 1; j < bitmapInfoHeader.biHeight - 1; j++)
		{

			newr = 0; newg = 0; newb = 0;
			rc = 0; gc = 0; bc = 0;

			for (int wi = -1; wi < 2; wi++)
				for (int hw = -1; hw < 2; hw++)
				{
					rc = bitecolor[i + hw][j + wi].rgbtRed;
					newr += g[wi + 1][hw + 1] * rc;

					gc = bitecolor[i + hw][j + wi].rgbtGreen;
					newg += g[wi + 1][hw + 1] * gc;

					bc = bitecolor[i + hw][j + wi].rgbtBlue;
					newb += g[wi + 1][hw + 1] * bc;
				}
			bitecolor[i][j].rgbtBlue = newb;
			bitecolor[i][j].rgbtGreen = newg;
			bitecolor[i][j].rgbtRed = newr;
		}

	createbmp(bitmapInfoHeader, bitmapFileHeader, bitecolor);
}

int main()
{
	FILE *file;
	file = fopen("unicorn.bmp", "r");

	fread(&bitmapFileHeader, sizeof(BITMAPFILEHEADER), 1, file);
	fread(&bitmapInfoHeader, sizeof(BITMAPINFOHEADER), 1, file);

	bitecolor = (RGBTRIPLE **)malloc(sizeof(RGBTRIPLE*) * bitmapInfoHeader.biWidth);
	for (int j = 0; j < bitmapInfoHeader.biWidth; j++)
		bitecolor[j] = (RGBTRIPLE *)malloc(sizeof(RGBTRIPLE) * bitmapInfoHeader.biHeight);

	fseek(file, bitmapFileHeader.bfOffBits, SEEK_SET);
	int padding = (-((bitmapInfoHeader.biWidth * bitmapInfoHeader.biBitCount / 8) % 4) + 4) % 4;
	char *buf = malloc(sizeof(char) * 4);
	for (int i = 0; i < bitmapInfoHeader.biWidth; i++)
	{
		for (int j = 0; j < bitmapInfoHeader.biHeight; j++)
			fread(&(bitecolor[i][j]), sizeof(bitecolor[i][j]), 1, file);
		fread(buf, sizeof(BYTE), padding, file);
	}

	createbmp(bitmapInfoHeader, bitmapFileHeader, bitecolor);

	//grey(bitmapInfoHeader, bitmapFileHeader, bitecolor);

	//median(bitmapInfoHeader, bitmapFileHeader, bitecolor);

	//gauss(5, bitmapInfoHeader, bitmapFileHeader, bitecolor);

	//sobelx(bitmapInfoHeader, bitmapFileHeader, bitecolor);

	//sobely(bitmapInfoHeader, bitmapFileHeader, bitecolor);
	return 0;
}